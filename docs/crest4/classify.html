<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>crest4.classify API documentation</title>
<meta name="description" content="Written by Lucas Sinclair.
GNUv3 Licensed.
Contact at www.sinclair.bio
Created in May 2021." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>crest4.classify</code></h1>
</header>
<section id="section-intro">
<p>Written by Lucas Sinclair.
GNUv3 Licensed.
Contact at www.sinclair.bio
Created in May 2021.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-

&#34;&#34;&#34;
Written by Lucas Sinclair.
GNUv3 Licensed.
Contact at www.sinclair.bio
Created in May 2021.
&#34;&#34;&#34;

# Built-in modules #
import os, multiprocessing

# Internal modules #
import crest4.databases
from crest4.query import Query

# First party modules #
from plumbing.cache      import property_cached
from seqsearch.search    import SeqSearch
from fasta               import FASTA
from autopaths.file_path import FilePath
from autopaths.dir_path  import DirectoryPath

###############################################################################
class Classify:
    &#34;&#34;&#34;
    This is the main object offered by the `crest4` package.
    It enables you to automatically assign taxonomic names to DNA sequences
    obtained from environmental sequencing.

    After creating a new instance of a `Classify` object, you can simply call
    it to have it process your input data and generate the assignments output
    file. Examples are included in the README.md file of this package or
    directly on the github page at:

    https://github.com/xapple/crest4/
    &#34;&#34;&#34;

    def __init__(self,
                 fasta,
                 search_algo = &#39;blast&#39;,
                 num_threads = 1,
                 search_db   = &#39;silvamod138&#39;,
                 output_dir  = None,
                 search_hits = None,
                 min_score   = None,
                 score_drop  = 2.0,
                 min_smlrty  = True,
                 ):
        &#34;&#34;&#34;
        Args:

            fasta: The path to a single FASTA file as a string.
                   These are the sequences that will be taxonomically
                   classified.

            search_algo: The algorithm used for the sequence similarity search
                         that will be run to match the sequences against the
                         database chosen. Either `blast` or `vsearch`. No
                         other values are currently supported. By default
                         `blast`.

            num_threads: The number of processors to use for the sequence
                         similarity search. By default parallelism is turned
                         off and this value is 1. If you pass the value `True`
                         we will run as many processes as there are CPUs but
                         no more than 32.

            search_db: The database used for the sequence similarity search.
                       Either `silvamod138` or `silvamod128`. No other values
                       are currently supported. By default `silvamod138`.
                       Optionally the user can provide his own custom database
                       by specifying the full path to a directory containing
                       all required files under `search_db`. See README.

            output_dir: The directory into which all the classification
                        results will be written to. This defaults to a
                        directory with the same name as the original FASTA
                        file and a `.crest4` suffix appended.

            search_hits: The path where the search results will be stored.
                         This defaults to the output directory. However,
                         if the search operation has already been completed
                         before hand, specify the path here to skip the
                         sequence similarity search step and go directly to
                         the taxonomy step. If a hits file exists in the output
                         directory and this option is not specified, it is
                         deleted and regenerated.

            min_score: The minimum bit-score for a search hit to be considered
                       when using BLAST as the search algorithm. All hits below
                       this score are ignored. When using VSEARCH, this value
                       instead indicates the minimum identity between two
                       sequences for the hit to be considered.
                       The default is `155` for BLAST and `0.75` for VSEARCH.

            score_drop: Determines the range of hits to retain and the range
                        to discard based on a drop in percentage from the score
                        of the best hit. Any hit below the following value:
                        &#34;(100 - score_drop)/100 * best_hit_score&#34; is ignored.
                        By default `2.0`.

            min_smlrty: Determines if the minimum similarity filter is turned
                        on or off. Pass the value `False` to turn it off.
                        The minimum similarity filter prevents classification
                        to higher ranks when a minimum rank-identity is not met.
                        By default `True`.
        &#34;&#34;&#34;
        # Save attributes #
        self.fasta       = fasta
        self.search_algo = search_algo
        self.num_threads = num_threads
        self.search_db   = search_db
        self.output_dir  = output_dir
        self.search_hits = search_hits
        self.min_score   = min_score
        self.score_drop  = score_drop
        self.min_smlrty  = min_smlrty
        # Assign default values and change others #
        self.transform()
        # Validate attributes #
        self.validate()

    def transform(self):
        &#34;&#34;&#34;
        This method will replace empty attributes with defaults when this is
        needed and will convert others to proper types.
        &#34;&#34;&#34;
        # The fasta should be a FASTA object #
        if self.fasta is not None:
            self.fasta = FASTA(self.fasta)
        # Default for the number of threads #
        if not isinstance(self.num_threads, int):
            if self.num_threads is True:
                self.num_threads = min(multiprocessing.cpu_count(), 32)
            elif self.num_threads is False:
                self.num_threads = 1
            elif self.num_threads.lower() == &#39;true&#39;:
                self.num_threads = min(multiprocessing.cpu_count(), 32)
        # Default for the output directory #
        if self.output_dir is None:
            self.output_dir = self.fasta + &#39;.crest4/&#39;
        self.output_dir = DirectoryPath(self.output_dir)
        # The search hits is a file somewhere if passed #
        if self.search_hits is not None:
            self.search_hits = FilePath(self.search_hits)
            self.search_hits.must_exist()
        # Default for the search hits file if not passed #
        if self.search_hits is None:
            self.search_hits = FilePath(self.output_dir + &#39;search.hits&#39;)
            self.search_hits.remove()
        # Default for the minimum score #
        if self.min_score is None:
            if self.search_algo == &#39;blast&#39;:
                self.min_score = 155
            if self.search_algo == &#39;vsearch&#39;:
                self.min_score = 0.75

    def validate(self):
        &#34;&#34;&#34;
        This method will raise an Exception if any of the arguments passed by
        the user are illegal.
        &#34;&#34;&#34;
        # The fasta should exist if passed #
        if self.fasta is not None:
            self.fasta.must_exist()
        # Either the FASTA file or the hits file has to contain something #
        if not self.fasta and not self.search_hits:
            msg = &#34;Neither the FASTA file at &#39;%s&#39; nor the search hits file at&#34; \
                  &#34; &#39;%s&#39; contain any data. Cannot proceed.&#34;
            raise Exception(msg % (self.fasta, self.search_hits))
        # Check the search algorithm #
        if self.search_algo not in (&#39;blast&#39;, &#39;vsearch&#39;):
            msg = &#34;The search algorithm &#39;%s&#39; is not supported.&#34;
            raise ValueError(msg % self.search_algo)
        # Check the search database #
        if self.search_db not in (&#39;silvamod128&#39;, &#39;silvamod138&#39;):
            msg = &#34;The search database &#39;%s&#39; is not supported.&#34;
            raise ValueError(msg % self.search_db)
        # Check the minimum score value above zero #
        if self.min_score &lt; 0.0:
            msg = &#34;The minimum score cannot be smaller than zero (&#39;%s&#39;).&#34;
            raise ValueError(msg % self.min_score)
        # Check the minimum score value below zero #
        if self.min_score &gt; 1.0:
            if self.search_algo == &#39;vsearch&#39;:
                msg = &#34;The minimum score cannot be more than 1.0 when&#34; \
                      &#34; using VSEARCH (&#39;%s&#39;) because it represents the&#34; \
                      &#34; the minimum identity between two sequences.&#34;
                raise ValueError(msg % self.min_score)
        # Check the score drop value #
        if self.score_drop &lt; 0.0:
            msg = &#34;The score drop value cannot be smaller than zero (&#39;%s&#39;).&#34;
            raise ValueError(msg % self.min_score)
        if self.score_drop &gt; 100.0:
            msg = &#34;The score drop value cannot be over 100 (&#39;%s&#39;).&#34;
            raise ValueError(msg % self.min_score)

    def __repr__(self):
        &#34;&#34;&#34;A simple representation of this object to avoid memory addresses.&#34;&#34;&#34;
        return &#34;&lt;%s object on &#39;%s&#39;&gt;&#34; % (self.__class__.__name__, self.fasta)

    @property_cached
    def database(self):
        &#34;&#34;&#34;Retrieve the database object that the user has selected.&#34;&#34;&#34;
        if &#39;/&#39; in self.search_db:
            short_name = os.path.basename(os.path.dirname(self.search_db))
            long_name  = &#34;Custom user provided database &#39;%s&#39;.&#34; % short_name
            return CrestDatabase(short_name, long_name, self.search_db)
        else:
            return getattr(crest4.databases, self.search_db)

    #------------------------------ Searching --------------------------------#
    @property_cached
    def seqsearch(self):
        &#34;&#34;&#34;
        An object representing the sequence similarity search.
        Makes use of the `seqsearch` module. For reference:
        * Setting `-outfmt` to 5 means XML output.
        * Setting `-outfmt` to 6 means tabular output.
        * Setting `-outfmt` to 7 means tabular output with comments.
        &#34;&#34;&#34;
        # Initialize #
        params = {}
        # If the user chose BLAST then we have to specify tabular output #
        if self.search_algo == &#39;blast&#39;:
            params = {&#39;-outfmt&#39;: &#39;7 qseqid sseqid bitscore length nident&#39;}
        # In case the user chose VSEARCH we specify the minimum identify #
        if self.search_algo == &#39;vsearch&#39;:
            params = {&#39;-id&#39;: self.min_score}
        # Build the object
        return SeqSearch(input_fasta = self.fasta,
                         database    = self.database,
                         seq_type    = &#39;nucl&#39;,
                         algorithm   = self.search_algo,
                         filtering   = {&#39;max_targets&#39;: 100},
                         num_threads = self.num_threads,
                         out_path    = self.search_hits,
                         params      = params)

    def search(self):
        &#34;&#34;&#34;A method to launch the sequence similarity search.&#34;&#34;&#34;
        # Launch the search algorithm #
        return self.seqsearch.run()

    #----------------------------- Assigning ---------------------------------#
    @property_cached
    def score_frac(self):
        &#34;&#34;&#34;
        Using the parameter `self.score_drop` which is a percentage (e.g. 2)
        indicating a drop, we compute the minimum remaining amount of score
        allowed, as a fraction (e.g. 0.98).
        &#34;&#34;&#34;
        return 1 - (self.score_drop / 100)

    @property_cached
    def queries(self):
        &#34;&#34;&#34;
        A list containing one Query object per sequence that was originally
        inputted. Use these objects to access the taxonomic assignments.
        &#34;&#34;&#34;
        # Check if the search has been done already #
        if not self.seqsearch: self.search()
        # Iterate on the sequence search results #
        return [Query(self, query) for query in self.seqsearch.results]

    @property_cached
    def queries_by_id(self):
        &#34;&#34;&#34;
        References the same Query objects as the `queries` property above,
        except that this time they are in a dictionary with the query ids
        (i.e. the original fasta ids) as keys instead of in a list.
        &#34;&#34;&#34;
        return {query.name: query for query in self.queries}

    #------------------------------- Outputs ---------------------------------#
    @property_cached
    def out_file(self):
        &#34;&#34;&#34;
        The path to the file that will contain the taxonomic assignments
        for every sequence.
        &#34;&#34;&#34;
        # Make sure that output directory exists #
        self.output_dir.create_if_not_exists()
        # Return #
        return self.output_dir + &#34;assignments.txt&#34;

    def __call__(self):
        &#34;&#34;&#34;Generate outputs.&#34;&#34;&#34;
        # Iterate #
        self.out_file.writelines(query.tax_string for query in self.queries)
        # Print a success message #
        msg = &#34;Classification ran successfully. Results are placed in &#39;%s&#39;&#34;
        print(msg % self.out_file)
        # Return #
        return self.out_file</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="crest4.classify.Classify"><code class="flex name class">
<span>class <span class="ident">Classify</span></span>
<span>(</span><span>fasta, search_algo='blast', num_threads=1, search_db='silvamod138', output_dir=None, search_hits=None, min_score=None, score_drop=2.0, min_smlrty=True)</span>
</code></dt>
<dd>
<div class="desc"><p>This is the main object offered by the <code><a title="crest4" href="index.html">crest4</a></code> package.
It enables you to automatically assign taxonomic names to DNA sequences
obtained from environmental sequencing.</p>
<p>After creating a new instance of a <code><a title="crest4.classify.Classify" href="#crest4.classify.Classify">Classify</a></code> object, you can simply call
it to have it process your input data and generate the assignments output
file. Examples are included in the README.md file of this package or
directly on the github page at:</p>
<p><a href="https://github.com/xapple/crest4/">https://github.com/xapple/crest4/</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fasta</code></strong></dt>
<dd>The path to a single FASTA file as a string.
These are the sequences that will be taxonomically
classified.</dd>
<dt><strong><code>search_algo</code></strong></dt>
<dd>The algorithm used for the sequence similarity search
that will be run to match the sequences against the
database chosen. Either <code>blast</code> or <code>vsearch</code>. No
other values are currently supported. By default
<code>blast</code>.</dd>
<dt><strong><code>num_threads</code></strong></dt>
<dd>The number of processors to use for the sequence
similarity search. By default parallelism is turned
off and this value is 1. If you pass the value <code>True</code>
we will run as many processes as there are CPUs but
no more than 32.</dd>
<dt><strong><code>search_db</code></strong></dt>
<dd>The database used for the sequence similarity search.
Either <code>silvamod138</code> or <code>silvamod128</code>. No other values
are currently supported. By default <code>silvamod138</code>.
Optionally the user can provide his own custom database
by specifying the full path to a directory containing
all required files under <code>search_db</code>. See README.</dd>
<dt><strong><code>output_dir</code></strong></dt>
<dd>The directory into which all the classification
results will be written to. This defaults to a
directory with the same name as the original FASTA
file and a <code>.<a title="crest4" href="index.html">crest4</a></code> suffix appended.</dd>
<dt><strong><code>search_hits</code></strong></dt>
<dd>The path where the search results will be stored.
This defaults to the output directory. However,
if the search operation has already been completed
before hand, specify the path here to skip the
sequence similarity search step and go directly to
the taxonomy step. If a hits file exists in the output
directory and this option is not specified, it is
deleted and regenerated.</dd>
<dt><strong><code>min_score</code></strong></dt>
<dd>The minimum bit-score for a search hit to be considered
when using BLAST as the search algorithm. All hits below
this score are ignored. When using VSEARCH, this value
instead indicates the minimum identity between two
sequences for the hit to be considered.
The default is <code>155</code> for BLAST and <code>0.75</code> for VSEARCH.</dd>
<dt><strong><code>score_drop</code></strong></dt>
<dd>Determines the range of hits to retain and the range
to discard based on a drop in percentage from the score
of the best hit. Any hit below the following value:
"(100 - score_drop)/100 * best_hit_score" is ignored.
By default <code>2.0</code>.</dd>
<dt><strong><code>min_smlrty</code></strong></dt>
<dd>Determines if the minimum similarity filter is turned
on or off. Pass the value <code>False</code> to turn it off.
The minimum similarity filter prevents classification
to higher ranks when a minimum rank-identity is not met.
By default <code>True</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Classify:
    &#34;&#34;&#34;
    This is the main object offered by the `crest4` package.
    It enables you to automatically assign taxonomic names to DNA sequences
    obtained from environmental sequencing.

    After creating a new instance of a `Classify` object, you can simply call
    it to have it process your input data and generate the assignments output
    file. Examples are included in the README.md file of this package or
    directly on the github page at:

    https://github.com/xapple/crest4/
    &#34;&#34;&#34;

    def __init__(self,
                 fasta,
                 search_algo = &#39;blast&#39;,
                 num_threads = 1,
                 search_db   = &#39;silvamod138&#39;,
                 output_dir  = None,
                 search_hits = None,
                 min_score   = None,
                 score_drop  = 2.0,
                 min_smlrty  = True,
                 ):
        &#34;&#34;&#34;
        Args:

            fasta: The path to a single FASTA file as a string.
                   These are the sequences that will be taxonomically
                   classified.

            search_algo: The algorithm used for the sequence similarity search
                         that will be run to match the sequences against the
                         database chosen. Either `blast` or `vsearch`. No
                         other values are currently supported. By default
                         `blast`.

            num_threads: The number of processors to use for the sequence
                         similarity search. By default parallelism is turned
                         off and this value is 1. If you pass the value `True`
                         we will run as many processes as there are CPUs but
                         no more than 32.

            search_db: The database used for the sequence similarity search.
                       Either `silvamod138` or `silvamod128`. No other values
                       are currently supported. By default `silvamod138`.
                       Optionally the user can provide his own custom database
                       by specifying the full path to a directory containing
                       all required files under `search_db`. See README.

            output_dir: The directory into which all the classification
                        results will be written to. This defaults to a
                        directory with the same name as the original FASTA
                        file and a `.crest4` suffix appended.

            search_hits: The path where the search results will be stored.
                         This defaults to the output directory. However,
                         if the search operation has already been completed
                         before hand, specify the path here to skip the
                         sequence similarity search step and go directly to
                         the taxonomy step. If a hits file exists in the output
                         directory and this option is not specified, it is
                         deleted and regenerated.

            min_score: The minimum bit-score for a search hit to be considered
                       when using BLAST as the search algorithm. All hits below
                       this score are ignored. When using VSEARCH, this value
                       instead indicates the minimum identity between two
                       sequences for the hit to be considered.
                       The default is `155` for BLAST and `0.75` for VSEARCH.

            score_drop: Determines the range of hits to retain and the range
                        to discard based on a drop in percentage from the score
                        of the best hit. Any hit below the following value:
                        &#34;(100 - score_drop)/100 * best_hit_score&#34; is ignored.
                        By default `2.0`.

            min_smlrty: Determines if the minimum similarity filter is turned
                        on or off. Pass the value `False` to turn it off.
                        The minimum similarity filter prevents classification
                        to higher ranks when a minimum rank-identity is not met.
                        By default `True`.
        &#34;&#34;&#34;
        # Save attributes #
        self.fasta       = fasta
        self.search_algo = search_algo
        self.num_threads = num_threads
        self.search_db   = search_db
        self.output_dir  = output_dir
        self.search_hits = search_hits
        self.min_score   = min_score
        self.score_drop  = score_drop
        self.min_smlrty  = min_smlrty
        # Assign default values and change others #
        self.transform()
        # Validate attributes #
        self.validate()

    def transform(self):
        &#34;&#34;&#34;
        This method will replace empty attributes with defaults when this is
        needed and will convert others to proper types.
        &#34;&#34;&#34;
        # The fasta should be a FASTA object #
        if self.fasta is not None:
            self.fasta = FASTA(self.fasta)
        # Default for the number of threads #
        if not isinstance(self.num_threads, int):
            if self.num_threads is True:
                self.num_threads = min(multiprocessing.cpu_count(), 32)
            elif self.num_threads is False:
                self.num_threads = 1
            elif self.num_threads.lower() == &#39;true&#39;:
                self.num_threads = min(multiprocessing.cpu_count(), 32)
        # Default for the output directory #
        if self.output_dir is None:
            self.output_dir = self.fasta + &#39;.crest4/&#39;
        self.output_dir = DirectoryPath(self.output_dir)
        # The search hits is a file somewhere if passed #
        if self.search_hits is not None:
            self.search_hits = FilePath(self.search_hits)
            self.search_hits.must_exist()
        # Default for the search hits file if not passed #
        if self.search_hits is None:
            self.search_hits = FilePath(self.output_dir + &#39;search.hits&#39;)
            self.search_hits.remove()
        # Default for the minimum score #
        if self.min_score is None:
            if self.search_algo == &#39;blast&#39;:
                self.min_score = 155
            if self.search_algo == &#39;vsearch&#39;:
                self.min_score = 0.75

    def validate(self):
        &#34;&#34;&#34;
        This method will raise an Exception if any of the arguments passed by
        the user are illegal.
        &#34;&#34;&#34;
        # The fasta should exist if passed #
        if self.fasta is not None:
            self.fasta.must_exist()
        # Either the FASTA file or the hits file has to contain something #
        if not self.fasta and not self.search_hits:
            msg = &#34;Neither the FASTA file at &#39;%s&#39; nor the search hits file at&#34; \
                  &#34; &#39;%s&#39; contain any data. Cannot proceed.&#34;
            raise Exception(msg % (self.fasta, self.search_hits))
        # Check the search algorithm #
        if self.search_algo not in (&#39;blast&#39;, &#39;vsearch&#39;):
            msg = &#34;The search algorithm &#39;%s&#39; is not supported.&#34;
            raise ValueError(msg % self.search_algo)
        # Check the search database #
        if self.search_db not in (&#39;silvamod128&#39;, &#39;silvamod138&#39;):
            msg = &#34;The search database &#39;%s&#39; is not supported.&#34;
            raise ValueError(msg % self.search_db)
        # Check the minimum score value above zero #
        if self.min_score &lt; 0.0:
            msg = &#34;The minimum score cannot be smaller than zero (&#39;%s&#39;).&#34;
            raise ValueError(msg % self.min_score)
        # Check the minimum score value below zero #
        if self.min_score &gt; 1.0:
            if self.search_algo == &#39;vsearch&#39;:
                msg = &#34;The minimum score cannot be more than 1.0 when&#34; \
                      &#34; using VSEARCH (&#39;%s&#39;) because it represents the&#34; \
                      &#34; the minimum identity between two sequences.&#34;
                raise ValueError(msg % self.min_score)
        # Check the score drop value #
        if self.score_drop &lt; 0.0:
            msg = &#34;The score drop value cannot be smaller than zero (&#39;%s&#39;).&#34;
            raise ValueError(msg % self.min_score)
        if self.score_drop &gt; 100.0:
            msg = &#34;The score drop value cannot be over 100 (&#39;%s&#39;).&#34;
            raise ValueError(msg % self.min_score)

    def __repr__(self):
        &#34;&#34;&#34;A simple representation of this object to avoid memory addresses.&#34;&#34;&#34;
        return &#34;&lt;%s object on &#39;%s&#39;&gt;&#34; % (self.__class__.__name__, self.fasta)

    @property_cached
    def database(self):
        &#34;&#34;&#34;Retrieve the database object that the user has selected.&#34;&#34;&#34;
        if &#39;/&#39; in self.search_db:
            short_name = os.path.basename(os.path.dirname(self.search_db))
            long_name  = &#34;Custom user provided database &#39;%s&#39;.&#34; % short_name
            return CrestDatabase(short_name, long_name, self.search_db)
        else:
            return getattr(crest4.databases, self.search_db)

    #------------------------------ Searching --------------------------------#
    @property_cached
    def seqsearch(self):
        &#34;&#34;&#34;
        An object representing the sequence similarity search.
        Makes use of the `seqsearch` module. For reference:
        * Setting `-outfmt` to 5 means XML output.
        * Setting `-outfmt` to 6 means tabular output.
        * Setting `-outfmt` to 7 means tabular output with comments.
        &#34;&#34;&#34;
        # Initialize #
        params = {}
        # If the user chose BLAST then we have to specify tabular output #
        if self.search_algo == &#39;blast&#39;:
            params = {&#39;-outfmt&#39;: &#39;7 qseqid sseqid bitscore length nident&#39;}
        # In case the user chose VSEARCH we specify the minimum identify #
        if self.search_algo == &#39;vsearch&#39;:
            params = {&#39;-id&#39;: self.min_score}
        # Build the object
        return SeqSearch(input_fasta = self.fasta,
                         database    = self.database,
                         seq_type    = &#39;nucl&#39;,
                         algorithm   = self.search_algo,
                         filtering   = {&#39;max_targets&#39;: 100},
                         num_threads = self.num_threads,
                         out_path    = self.search_hits,
                         params      = params)

    def search(self):
        &#34;&#34;&#34;A method to launch the sequence similarity search.&#34;&#34;&#34;
        # Launch the search algorithm #
        return self.seqsearch.run()

    #----------------------------- Assigning ---------------------------------#
    @property_cached
    def score_frac(self):
        &#34;&#34;&#34;
        Using the parameter `self.score_drop` which is a percentage (e.g. 2)
        indicating a drop, we compute the minimum remaining amount of score
        allowed, as a fraction (e.g. 0.98).
        &#34;&#34;&#34;
        return 1 - (self.score_drop / 100)

    @property_cached
    def queries(self):
        &#34;&#34;&#34;
        A list containing one Query object per sequence that was originally
        inputted. Use these objects to access the taxonomic assignments.
        &#34;&#34;&#34;
        # Check if the search has been done already #
        if not self.seqsearch: self.search()
        # Iterate on the sequence search results #
        return [Query(self, query) for query in self.seqsearch.results]

    @property_cached
    def queries_by_id(self):
        &#34;&#34;&#34;
        References the same Query objects as the `queries` property above,
        except that this time they are in a dictionary with the query ids
        (i.e. the original fasta ids) as keys instead of in a list.
        &#34;&#34;&#34;
        return {query.name: query for query in self.queries}

    #------------------------------- Outputs ---------------------------------#
    @property_cached
    def out_file(self):
        &#34;&#34;&#34;
        The path to the file that will contain the taxonomic assignments
        for every sequence.
        &#34;&#34;&#34;
        # Make sure that output directory exists #
        self.output_dir.create_if_not_exists()
        # Return #
        return self.output_dir + &#34;assignments.txt&#34;

    def __call__(self):
        &#34;&#34;&#34;Generate outputs.&#34;&#34;&#34;
        # Iterate #
        self.out_file.writelines(query.tax_string for query in self.queries)
        # Print a success message #
        msg = &#34;Classification ran successfully. Results are placed in &#39;%s&#39;&#34;
        print(msg % self.out_file)
        # Return #
        return self.out_file</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="crest4.classify.Classify.database"><code class="name">var <span class="ident">database</span></code></dt>
<dd>
<div class="desc"><p>Retrieve the database object that the user has selected.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    &#34;&#34;&#34;
    If you see the current source code in a seemingly unrelated part of
    an auto-generated documentation, it means the program making the
    documentation was unable to correctly traverse a decorated property.
    &#34;&#34;&#34;
    # For debugging purposes #
    if False: print(&#34;-&gt; property cached `%s`&#34; % instance)
    # If called from a class #
    if instance is None: return self
    # Does a cache exist for this instance? #
    self.check_cache(instance)
    # Is the answer in the cache? #
    if self.name in instance.__cache__: return instance.__cache__[self.name]
    # If not we will compute it #
    if inspect.isgeneratorfunction(self.func): result = tuple(self.func(instance))
    else:                                      result = self.func(instance)
    # Let&#39;s store the answer for later #
    instance.__cache__[self.name] = result
    # Return #
    return result</code></pre>
</details>
</dd>
<dt id="crest4.classify.Classify.out_file"><code class="name">var <span class="ident">out_file</span></code></dt>
<dd>
<div class="desc"><p>The path to the file that will contain the taxonomic assignments
for every sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    &#34;&#34;&#34;
    If you see the current source code in a seemingly unrelated part of
    an auto-generated documentation, it means the program making the
    documentation was unable to correctly traverse a decorated property.
    &#34;&#34;&#34;
    # For debugging purposes #
    if False: print(&#34;-&gt; property cached `%s`&#34; % instance)
    # If called from a class #
    if instance is None: return self
    # Does a cache exist for this instance? #
    self.check_cache(instance)
    # Is the answer in the cache? #
    if self.name in instance.__cache__: return instance.__cache__[self.name]
    # If not we will compute it #
    if inspect.isgeneratorfunction(self.func): result = tuple(self.func(instance))
    else:                                      result = self.func(instance)
    # Let&#39;s store the answer for later #
    instance.__cache__[self.name] = result
    # Return #
    return result</code></pre>
</details>
</dd>
<dt id="crest4.classify.Classify.queries"><code class="name">var <span class="ident">queries</span></code></dt>
<dd>
<div class="desc"><p>A list containing one Query object per sequence that was originally
inputted. Use these objects to access the taxonomic assignments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    &#34;&#34;&#34;
    If you see the current source code in a seemingly unrelated part of
    an auto-generated documentation, it means the program making the
    documentation was unable to correctly traverse a decorated property.
    &#34;&#34;&#34;
    # For debugging purposes #
    if False: print(&#34;-&gt; property cached `%s`&#34; % instance)
    # If called from a class #
    if instance is None: return self
    # Does a cache exist for this instance? #
    self.check_cache(instance)
    # Is the answer in the cache? #
    if self.name in instance.__cache__: return instance.__cache__[self.name]
    # If not we will compute it #
    if inspect.isgeneratorfunction(self.func): result = tuple(self.func(instance))
    else:                                      result = self.func(instance)
    # Let&#39;s store the answer for later #
    instance.__cache__[self.name] = result
    # Return #
    return result</code></pre>
</details>
</dd>
<dt id="crest4.classify.Classify.queries_by_id"><code class="name">var <span class="ident">queries_by_id</span></code></dt>
<dd>
<div class="desc"><p>References the same Query objects as the <code>queries</code> property above,
except that this time they are in a dictionary with the query ids
(i.e. the original fasta ids) as keys instead of in a list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    &#34;&#34;&#34;
    If you see the current source code in a seemingly unrelated part of
    an auto-generated documentation, it means the program making the
    documentation was unable to correctly traverse a decorated property.
    &#34;&#34;&#34;
    # For debugging purposes #
    if False: print(&#34;-&gt; property cached `%s`&#34; % instance)
    # If called from a class #
    if instance is None: return self
    # Does a cache exist for this instance? #
    self.check_cache(instance)
    # Is the answer in the cache? #
    if self.name in instance.__cache__: return instance.__cache__[self.name]
    # If not we will compute it #
    if inspect.isgeneratorfunction(self.func): result = tuple(self.func(instance))
    else:                                      result = self.func(instance)
    # Let&#39;s store the answer for later #
    instance.__cache__[self.name] = result
    # Return #
    return result</code></pre>
</details>
</dd>
<dt id="crest4.classify.Classify.score_frac"><code class="name">var <span class="ident">score_frac</span></code></dt>
<dd>
<div class="desc"><p>Using the parameter <code>self.score_drop</code> which is a percentage (e.g. 2)
indicating a drop, we compute the minimum remaining amount of score
allowed, as a fraction (e.g. 0.98).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    &#34;&#34;&#34;
    If you see the current source code in a seemingly unrelated part of
    an auto-generated documentation, it means the program making the
    documentation was unable to correctly traverse a decorated property.
    &#34;&#34;&#34;
    # For debugging purposes #
    if False: print(&#34;-&gt; property cached `%s`&#34; % instance)
    # If called from a class #
    if instance is None: return self
    # Does a cache exist for this instance? #
    self.check_cache(instance)
    # Is the answer in the cache? #
    if self.name in instance.__cache__: return instance.__cache__[self.name]
    # If not we will compute it #
    if inspect.isgeneratorfunction(self.func): result = tuple(self.func(instance))
    else:                                      result = self.func(instance)
    # Let&#39;s store the answer for later #
    instance.__cache__[self.name] = result
    # Return #
    return result</code></pre>
</details>
</dd>
<dt id="crest4.classify.Classify.seqsearch"><code class="name">var <span class="ident">seqsearch</span></code></dt>
<dd>
<div class="desc"><p>An object representing the sequence similarity search.
Makes use of the <code>seqsearch</code> module. For reference:
* Setting <code>-outfmt</code> to 5 means XML output.
* Setting <code>-outfmt</code> to 6 means tabular output.
* Setting <code>-outfmt</code> to 7 means tabular output with comments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    &#34;&#34;&#34;
    If you see the current source code in a seemingly unrelated part of
    an auto-generated documentation, it means the program making the
    documentation was unable to correctly traverse a decorated property.
    &#34;&#34;&#34;
    # For debugging purposes #
    if False: print(&#34;-&gt; property cached `%s`&#34; % instance)
    # If called from a class #
    if instance is None: return self
    # Does a cache exist for this instance? #
    self.check_cache(instance)
    # Is the answer in the cache? #
    if self.name in instance.__cache__: return instance.__cache__[self.name]
    # If not we will compute it #
    if inspect.isgeneratorfunction(self.func): result = tuple(self.func(instance))
    else:                                      result = self.func(instance)
    # Let&#39;s store the answer for later #
    instance.__cache__[self.name] = result
    # Return #
    return result</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="crest4.classify.Classify.search"><code class="name flex">
<span>def <span class="ident">search</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A method to launch the sequence similarity search.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search(self):
    &#34;&#34;&#34;A method to launch the sequence similarity search.&#34;&#34;&#34;
    # Launch the search algorithm #
    return self.seqsearch.run()</code></pre>
</details>
</dd>
<dt id="crest4.classify.Classify.transform"><code class="name flex">
<span>def <span class="ident">transform</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method will replace empty attributes with defaults when this is
needed and will convert others to proper types.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform(self):
    &#34;&#34;&#34;
    This method will replace empty attributes with defaults when this is
    needed and will convert others to proper types.
    &#34;&#34;&#34;
    # The fasta should be a FASTA object #
    if self.fasta is not None:
        self.fasta = FASTA(self.fasta)
    # Default for the number of threads #
    if not isinstance(self.num_threads, int):
        if self.num_threads is True:
            self.num_threads = min(multiprocessing.cpu_count(), 32)
        elif self.num_threads is False:
            self.num_threads = 1
        elif self.num_threads.lower() == &#39;true&#39;:
            self.num_threads = min(multiprocessing.cpu_count(), 32)
    # Default for the output directory #
    if self.output_dir is None:
        self.output_dir = self.fasta + &#39;.crest4/&#39;
    self.output_dir = DirectoryPath(self.output_dir)
    # The search hits is a file somewhere if passed #
    if self.search_hits is not None:
        self.search_hits = FilePath(self.search_hits)
        self.search_hits.must_exist()
    # Default for the search hits file if not passed #
    if self.search_hits is None:
        self.search_hits = FilePath(self.output_dir + &#39;search.hits&#39;)
        self.search_hits.remove()
    # Default for the minimum score #
    if self.min_score is None:
        if self.search_algo == &#39;blast&#39;:
            self.min_score = 155
        if self.search_algo == &#39;vsearch&#39;:
            self.min_score = 0.75</code></pre>
</details>
</dd>
<dt id="crest4.classify.Classify.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method will raise an Exception if any of the arguments passed by
the user are illegal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self):
    &#34;&#34;&#34;
    This method will raise an Exception if any of the arguments passed by
    the user are illegal.
    &#34;&#34;&#34;
    # The fasta should exist if passed #
    if self.fasta is not None:
        self.fasta.must_exist()
    # Either the FASTA file or the hits file has to contain something #
    if not self.fasta and not self.search_hits:
        msg = &#34;Neither the FASTA file at &#39;%s&#39; nor the search hits file at&#34; \
              &#34; &#39;%s&#39; contain any data. Cannot proceed.&#34;
        raise Exception(msg % (self.fasta, self.search_hits))
    # Check the search algorithm #
    if self.search_algo not in (&#39;blast&#39;, &#39;vsearch&#39;):
        msg = &#34;The search algorithm &#39;%s&#39; is not supported.&#34;
        raise ValueError(msg % self.search_algo)
    # Check the search database #
    if self.search_db not in (&#39;silvamod128&#39;, &#39;silvamod138&#39;):
        msg = &#34;The search database &#39;%s&#39; is not supported.&#34;
        raise ValueError(msg % self.search_db)
    # Check the minimum score value above zero #
    if self.min_score &lt; 0.0:
        msg = &#34;The minimum score cannot be smaller than zero (&#39;%s&#39;).&#34;
        raise ValueError(msg % self.min_score)
    # Check the minimum score value below zero #
    if self.min_score &gt; 1.0:
        if self.search_algo == &#39;vsearch&#39;:
            msg = &#34;The minimum score cannot be more than 1.0 when&#34; \
                  &#34; using VSEARCH (&#39;%s&#39;) because it represents the&#34; \
                  &#34; the minimum identity between two sequences.&#34;
            raise ValueError(msg % self.min_score)
    # Check the score drop value #
    if self.score_drop &lt; 0.0:
        msg = &#34;The score drop value cannot be smaller than zero (&#39;%s&#39;).&#34;
        raise ValueError(msg % self.min_score)
    if self.score_drop &gt; 100.0:
        msg = &#34;The score drop value cannot be over 100 (&#39;%s&#39;).&#34;
        raise ValueError(msg % self.min_score)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="crest4" href="index.html">crest4</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="crest4.classify.Classify" href="#crest4.classify.Classify">Classify</a></code></h4>
<ul class="two-column">
<li><code><a title="crest4.classify.Classify.database" href="#crest4.classify.Classify.database">database</a></code></li>
<li><code><a title="crest4.classify.Classify.out_file" href="#crest4.classify.Classify.out_file">out_file</a></code></li>
<li><code><a title="crest4.classify.Classify.queries" href="#crest4.classify.Classify.queries">queries</a></code></li>
<li><code><a title="crest4.classify.Classify.queries_by_id" href="#crest4.classify.Classify.queries_by_id">queries_by_id</a></code></li>
<li><code><a title="crest4.classify.Classify.score_frac" href="#crest4.classify.Classify.score_frac">score_frac</a></code></li>
<li><code><a title="crest4.classify.Classify.search" href="#crest4.classify.Classify.search">search</a></code></li>
<li><code><a title="crest4.classify.Classify.seqsearch" href="#crest4.classify.Classify.seqsearch">seqsearch</a></code></li>
<li><code><a title="crest4.classify.Classify.transform" href="#crest4.classify.Classify.transform">transform</a></code></li>
<li><code><a title="crest4.classify.Classify.validate" href="#crest4.classify.Classify.validate">validate</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>