<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>crest4.query API documentation</title>
<meta name="description" content="Written by Lucas Sinclair.
GNUv3 Licensed.
Contact at www.sinclair.bio
Created in May 2021." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>crest4.query</code></h1>
</header>
<section id="section-intro">
<p>Written by Lucas Sinclair.
GNUv3 Licensed.
Contact at www.sinclair.bio
Created in May 2021.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-

&#34;&#34;&#34;
Written by Lucas Sinclair.
GNUv3 Licensed.
Contact at www.sinclair.bio
Created in May 2021.
&#34;&#34;&#34;

# First party modules #
from plumbing.cache import property_cached

###############################################################################
class Query:
    &#34;&#34;&#34;
    Represents a single sequence (for instance an OTU) along with
    all the information pertaining to it, such as its taxonomic assignment.

    Takes care of assigning taxonomy by using the results of the sequence
    similarity search and a phylogenetic tree as a N-ary directed graph.

    The query parameter is a object coming from biopython and of type:
    &#39;Bio.SearchIO._model.query.QueryResult&#39;
    &#34;&#34;&#34;

    def __init__(self, classify, query):
        # A reference to the parent object #
        self.classify = classify
        # An object containing all the hit results for this sequence #
        self.query = query
        # Get the name #
        self.name = self.query.id
        # Shortcut to the database used #
        self.db = self.classify.database
        # Shortcut to the algorithm used #
        self.algo = self.classify.search_algo

    def __repr__(self):
        &#34;&#34;&#34;A simple representation of this object to avoid memory addresses.&#34;&#34;&#34;
        return &#34;&lt;%s object on &#39;%s&#39;&gt;&#34; % (self.__class__.__name__, self.name)

    #------------------------------ Properties -------------------------------#
    @property_cached
    def nodes(self):
        &#34;&#34;&#34;
        This function will return the nodes in the tree for which this
        sequence got at least one hit in a set.
        &#34;&#34;&#34;
        # Initialize the set that will hold all the nodes we find #
        nodes = set()
        # Check there was at least one hit #
        if len(self.query.hits) == 0: return nodes
        # Get the score of the best hit #
        if self.algo == &#39;blast&#39;:   top_score = self.query.hsps[0].bitscore
        if self.algo == &#39;vsearch&#39;: top_score = self.query.hsps[0].ident_pct/100
        # Check if the score is good enough to proceed further #
        if top_score &lt; self.classify.min_score: return nodes
        # Calculate the score-drop threshold based on the best hit #
        threshold = top_score * self.classify.score_frac
        # Iterate on the hits until falling below a threshold #
        for hsp in self.query.hsps:
            # Stop if the current bitscore is below our threshold #
            if self.algo == &#39;blast&#39;:   score = hsp.bitscore
            if self.algo == &#39;vsearch&#39;: score = hsp.ident_pct/100
            if score &lt; threshold: break
            # Get the name (or ID) of the current hit #
            name = hsp.hit_id
            # Get the corresponding node name in the tree #
            node = self.db.acc_to_node.get(name)
            # Check that it was found #
            if node is None:
                msg = &#34;The search hit &#39;%s&#39; was not found in the tree.&#34; \
                      &#34; The database &#39;%s&#39; is probably corrupted.&#34;
                raise Exception(msg % (name, self.db.short_name))
            # Add it to the list #
            nodes.add(node)
        # Return #
        return nodes

    @property_cached
    def assigned_node(self):
        &#34;&#34;&#34;
        This function will return the node in the tree at which the
        sequence was assigned. This could be the root of the tree or any
        other node.
        This function can also return `False` when there was no results.
        &#34;&#34;&#34;
        # If there are no hits #
        if len(self.nodes) == 0: return False
        # If there is only one hit, then get that node in the tree #
        if len(self.nodes) == 1:
            name, = self.nodes
            node = self.db.tree.search_nodes(name=name)[0]
        # Retrieve the lowest common node if more than one hit #
        else:
            node = self.db.tree.get_common_ancestor(self.nodes)
        # Calculate the similarity fraction of the best alignment #
        if self.algo == &#39;blast&#39;:
            ident_num = self.query.hsps[0].ident_num
            algn_span = self.query.fragments[0]._aln_span
            similarity = ident_num / algn_span
        if self.algo == &#39;vsearch&#39;:
            similarity = self.query.hsps[0].ident_pct/100
        # Check the minimum similarity criteria for assigning at a given
        # level and proceed ascending the tree until the similarity is
        # satisfactory.
        while True:
            # Check that the similarity filter is activated #
            if not self.classify.min_smlrty: break
            # Check if we already got all the way up to the root #
            if node.is_root(): break
            # Get the minimum value associated for this level #
            smlrty_min = float(self.db.node_to_name[node.name][1])
            # Check if we are finally above that minimum #
            if similarity &gt; smlrty_min: break
            # Otherwise go up one level for our classification #
            node = node.up
        # Return #
        return node

    @property_cached
    def taxonomy(self):
        &#34;&#34;&#34;
        This function will return a list containing the assigned taxonomy.

        For instance:
            [&#39;root&#39;, &#39;Main genome&#39;, &#39;Bacteria&#39;, &#39;Bacteria (superkingdom)&#39;,
             &#39;Terrabacteria&#39;, &#39;Actinobacteria&#39;, &#39;Actinobacteria (class)&#39;,
             &#39;Micrococcales&#39;, &#39;Micrococcaceae&#39;]
        &#34;&#34;&#34;
        # Check if there was no hits #
        if self.assigned_node is False: return [&#34;No hits&#34;]
        # Function to get the taxonomy name of a node
        get_tax = lambda node: self.db.node_to_name[node.name][0]
        # The taxonomic name of the current node #
        name = get_tax(self.assigned_node)
        # Traverse the tree up to the root #
        tree_path = self.assigned_node.iter_ancestors()
        # Get name of every parent along the way #
        return [name] + [get_tax(parent) for parent in tree_path]

    @property_cached
    def tax_string(self):
        &#34;&#34;&#34;
        This function will return a single comma-separated string containing
        the full assigned taxonomy along with the original name of the
        sequence classified.
        &#34;&#34;&#34;
        # Make a semi colon separated string #
        tax = &#39;; &#39;.join(reversed(self.taxonomy))
        # Add the name of the query to the beginning line #
        return self.name + &#39;\t&#39; + tax + &#39;\n&#39;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="crest4.query.Query"><code class="flex name class">
<span>class <span class="ident">Query</span></span>
<span>(</span><span>classify, query)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a single sequence (for instance an OTU) along with
all the information pertaining to it, such as its taxonomic assignment.</p>
<p>Takes care of assigning taxonomy by using the results of the sequence
similarity search and a phylogenetic tree as a N-ary directed graph.</p>
<p>The query parameter is a object coming from biopython and of type:
'Bio.SearchIO._model.query.QueryResult'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Query:
    &#34;&#34;&#34;
    Represents a single sequence (for instance an OTU) along with
    all the information pertaining to it, such as its taxonomic assignment.

    Takes care of assigning taxonomy by using the results of the sequence
    similarity search and a phylogenetic tree as a N-ary directed graph.

    The query parameter is a object coming from biopython and of type:
    &#39;Bio.SearchIO._model.query.QueryResult&#39;
    &#34;&#34;&#34;

    def __init__(self, classify, query):
        # A reference to the parent object #
        self.classify = classify
        # An object containing all the hit results for this sequence #
        self.query = query
        # Get the name #
        self.name = self.query.id
        # Shortcut to the database used #
        self.db = self.classify.database
        # Shortcut to the algorithm used #
        self.algo = self.classify.search_algo

    def __repr__(self):
        &#34;&#34;&#34;A simple representation of this object to avoid memory addresses.&#34;&#34;&#34;
        return &#34;&lt;%s object on &#39;%s&#39;&gt;&#34; % (self.__class__.__name__, self.name)

    #------------------------------ Properties -------------------------------#
    @property_cached
    def nodes(self):
        &#34;&#34;&#34;
        This function will return the nodes in the tree for which this
        sequence got at least one hit in a set.
        &#34;&#34;&#34;
        # Initialize the set that will hold all the nodes we find #
        nodes = set()
        # Check there was at least one hit #
        if len(self.query.hits) == 0: return nodes
        # Get the score of the best hit #
        if self.algo == &#39;blast&#39;:   top_score = self.query.hsps[0].bitscore
        if self.algo == &#39;vsearch&#39;: top_score = self.query.hsps[0].ident_pct/100
        # Check if the score is good enough to proceed further #
        if top_score &lt; self.classify.min_score: return nodes
        # Calculate the score-drop threshold based on the best hit #
        threshold = top_score * self.classify.score_frac
        # Iterate on the hits until falling below a threshold #
        for hsp in self.query.hsps:
            # Stop if the current bitscore is below our threshold #
            if self.algo == &#39;blast&#39;:   score = hsp.bitscore
            if self.algo == &#39;vsearch&#39;: score = hsp.ident_pct/100
            if score &lt; threshold: break
            # Get the name (or ID) of the current hit #
            name = hsp.hit_id
            # Get the corresponding node name in the tree #
            node = self.db.acc_to_node.get(name)
            # Check that it was found #
            if node is None:
                msg = &#34;The search hit &#39;%s&#39; was not found in the tree.&#34; \
                      &#34; The database &#39;%s&#39; is probably corrupted.&#34;
                raise Exception(msg % (name, self.db.short_name))
            # Add it to the list #
            nodes.add(node)
        # Return #
        return nodes

    @property_cached
    def assigned_node(self):
        &#34;&#34;&#34;
        This function will return the node in the tree at which the
        sequence was assigned. This could be the root of the tree or any
        other node.
        This function can also return `False` when there was no results.
        &#34;&#34;&#34;
        # If there are no hits #
        if len(self.nodes) == 0: return False
        # If there is only one hit, then get that node in the tree #
        if len(self.nodes) == 1:
            name, = self.nodes
            node = self.db.tree.search_nodes(name=name)[0]
        # Retrieve the lowest common node if more than one hit #
        else:
            node = self.db.tree.get_common_ancestor(self.nodes)
        # Calculate the similarity fraction of the best alignment #
        if self.algo == &#39;blast&#39;:
            ident_num = self.query.hsps[0].ident_num
            algn_span = self.query.fragments[0]._aln_span
            similarity = ident_num / algn_span
        if self.algo == &#39;vsearch&#39;:
            similarity = self.query.hsps[0].ident_pct/100
        # Check the minimum similarity criteria for assigning at a given
        # level and proceed ascending the tree until the similarity is
        # satisfactory.
        while True:
            # Check that the similarity filter is activated #
            if not self.classify.min_smlrty: break
            # Check if we already got all the way up to the root #
            if node.is_root(): break
            # Get the minimum value associated for this level #
            smlrty_min = float(self.db.node_to_name[node.name][1])
            # Check if we are finally above that minimum #
            if similarity &gt; smlrty_min: break
            # Otherwise go up one level for our classification #
            node = node.up
        # Return #
        return node

    @property_cached
    def taxonomy(self):
        &#34;&#34;&#34;
        This function will return a list containing the assigned taxonomy.

        For instance:
            [&#39;root&#39;, &#39;Main genome&#39;, &#39;Bacteria&#39;, &#39;Bacteria (superkingdom)&#39;,
             &#39;Terrabacteria&#39;, &#39;Actinobacteria&#39;, &#39;Actinobacteria (class)&#39;,
             &#39;Micrococcales&#39;, &#39;Micrococcaceae&#39;]
        &#34;&#34;&#34;
        # Check if there was no hits #
        if self.assigned_node is False: return [&#34;No hits&#34;]
        # Function to get the taxonomy name of a node
        get_tax = lambda node: self.db.node_to_name[node.name][0]
        # The taxonomic name of the current node #
        name = get_tax(self.assigned_node)
        # Traverse the tree up to the root #
        tree_path = self.assigned_node.iter_ancestors()
        # Get name of every parent along the way #
        return [name] + [get_tax(parent) for parent in tree_path]

    @property_cached
    def tax_string(self):
        &#34;&#34;&#34;
        This function will return a single comma-separated string containing
        the full assigned taxonomy along with the original name of the
        sequence classified.
        &#34;&#34;&#34;
        # Make a semi colon separated string #
        tax = &#39;; &#39;.join(reversed(self.taxonomy))
        # Add the name of the query to the beginning line #
        return self.name + &#39;\t&#39; + tax + &#39;\n&#39;</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="crest4.query.Query.assigned_node"><code class="name">var <span class="ident">assigned_node</span></code></dt>
<dd>
<div class="desc"><p>This function will return the node in the tree at which the
sequence was assigned. This could be the root of the tree or any
other node.
This function can also return <code>False</code> when there was no results.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    &#34;&#34;&#34;
    If you see the current source code in a seemingly unrelated part of
    an auto-generated documentation, it means the program making the
    documentation was unable to correctly traverse a decorated property.
    &#34;&#34;&#34;
    # For debugging purposes #
    if False: print(&#34;-&gt; property cached `%s`&#34; % instance)
    # If called from a class #
    if instance is None: return self
    # Does a cache exist for this instance? #
    self.check_cache(instance)
    # Is the answer in the cache? #
    if self.name in instance.__cache__: return instance.__cache__[self.name]
    # If not we will compute it #
    if inspect.isgeneratorfunction(self.func): result = tuple(self.func(instance))
    else:                                      result = self.func(instance)
    # Let&#39;s store the answer for later #
    instance.__cache__[self.name] = result
    # Return #
    return result</code></pre>
</details>
</dd>
<dt id="crest4.query.Query.nodes"><code class="name">var <span class="ident">nodes</span></code></dt>
<dd>
<div class="desc"><p>This function will return the nodes in the tree for which this
sequence got at least one hit in a set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    &#34;&#34;&#34;
    If you see the current source code in a seemingly unrelated part of
    an auto-generated documentation, it means the program making the
    documentation was unable to correctly traverse a decorated property.
    &#34;&#34;&#34;
    # For debugging purposes #
    if False: print(&#34;-&gt; property cached `%s`&#34; % instance)
    # If called from a class #
    if instance is None: return self
    # Does a cache exist for this instance? #
    self.check_cache(instance)
    # Is the answer in the cache? #
    if self.name in instance.__cache__: return instance.__cache__[self.name]
    # If not we will compute it #
    if inspect.isgeneratorfunction(self.func): result = tuple(self.func(instance))
    else:                                      result = self.func(instance)
    # Let&#39;s store the answer for later #
    instance.__cache__[self.name] = result
    # Return #
    return result</code></pre>
</details>
</dd>
<dt id="crest4.query.Query.tax_string"><code class="name">var <span class="ident">tax_string</span></code></dt>
<dd>
<div class="desc"><p>This function will return a single comma-separated string containing
the full assigned taxonomy along with the original name of the
sequence classified.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    &#34;&#34;&#34;
    If you see the current source code in a seemingly unrelated part of
    an auto-generated documentation, it means the program making the
    documentation was unable to correctly traverse a decorated property.
    &#34;&#34;&#34;
    # For debugging purposes #
    if False: print(&#34;-&gt; property cached `%s`&#34; % instance)
    # If called from a class #
    if instance is None: return self
    # Does a cache exist for this instance? #
    self.check_cache(instance)
    # Is the answer in the cache? #
    if self.name in instance.__cache__: return instance.__cache__[self.name]
    # If not we will compute it #
    if inspect.isgeneratorfunction(self.func): result = tuple(self.func(instance))
    else:                                      result = self.func(instance)
    # Let&#39;s store the answer for later #
    instance.__cache__[self.name] = result
    # Return #
    return result</code></pre>
</details>
</dd>
<dt id="crest4.query.Query.taxonomy"><code class="name">var <span class="ident">taxonomy</span></code></dt>
<dd>
<div class="desc"><p>This function will return a list containing the assigned taxonomy.</p>
<p>For instance:
['root', 'Main genome', 'Bacteria', 'Bacteria (superkingdom)',
'Terrabacteria', 'Actinobacteria', 'Actinobacteria (class)',
'Micrococcales', 'Micrococcaceae']</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    &#34;&#34;&#34;
    If you see the current source code in a seemingly unrelated part of
    an auto-generated documentation, it means the program making the
    documentation was unable to correctly traverse a decorated property.
    &#34;&#34;&#34;
    # For debugging purposes #
    if False: print(&#34;-&gt; property cached `%s`&#34; % instance)
    # If called from a class #
    if instance is None: return self
    # Does a cache exist for this instance? #
    self.check_cache(instance)
    # Is the answer in the cache? #
    if self.name in instance.__cache__: return instance.__cache__[self.name]
    # If not we will compute it #
    if inspect.isgeneratorfunction(self.func): result = tuple(self.func(instance))
    else:                                      result = self.func(instance)
    # Let&#39;s store the answer for later #
    instance.__cache__[self.name] = result
    # Return #
    return result</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="crest4" href="index.html">crest4</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="crest4.query.Query" href="#crest4.query.Query">Query</a></code></h4>
<ul class="">
<li><code><a title="crest4.query.Query.assigned_node" href="#crest4.query.Query.assigned_node">assigned_node</a></code></li>
<li><code><a title="crest4.query.Query.nodes" href="#crest4.query.Query.nodes">nodes</a></code></li>
<li><code><a title="crest4.query.Query.tax_string" href="#crest4.query.Query.tax_string">tax_string</a></code></li>
<li><code><a title="crest4.query.Query.taxonomy" href="#crest4.query.Query.taxonomy">taxonomy</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>